// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}


datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Store Model
// 
// Represents a physical store location in the retail network.
// Each store has inventory stock, sales.
// 
// Relationships:
// - One-to-Many with Stock: A store has multiple product stock records
// - One-to-Many with Sale: A store processes multiple sales
// - One-to-Many with Refund: A store processes multiple refunds
model Store {
  id        Int      @id @default(autoincrement())
  name      String
  address   String?
  stocks    Stock[]
  sales     Sale[]
  refunds   Refund[]

  @@map("Store")
}

// Product Model
// 
// Represents a product in the retail catalog.
// Products are stocked in stores, sold through sales.
// 
// Relationships:
// - One-to-Many with Stock: A product can be stocked in multiple stores
// - One-to-Many with SaleLine: A product can appear in multiple sale line items
// - One-to-Many with RefundLine: A product can be refunded in multiple refund line items
model Product {
  id          Int           @id @default(autoincrement())
  name        String        @map("name")
  price       Float         @map("price")
  description String?
  stocks      Stock[]
  saleLines   SaleLine[]    @relation("ProductToSaleLine")
  refundLines RefundLine[]  @relation("ProductToRefundLine")

  @@map("Product")
}

// Stock Model
// 
// Represents the inventory level of a specific product in a specific store.
// This is a join table with additional data (quantity) between Store and Product.
// 
// Relationships:
// - Many-to-One with Store: Each stock record belongs to one store
// - Many-to-One with Product: Each stock record is for one product
// 
// Constraints:
// - Unique combination of storeId and productId ensures only one stock record
//   exists per product per store
model Stock {
  id         Int      @id @default(autoincrement())
  quantity   Int      @default(0) @map("quantity")
  store      Store    @relation(fields: [storeId], references: [id])
  storeId    Int      @map("storeId")
  product    Product  @relation(fields: [productId], references: [id])
  productId  Int

  @@unique([storeId, productId])
  @@map("Stock")
}

// User Model
// 
// Represents a user who can either be a client or manager
// Users are identified by name and can have multiple sales transactions if they are clients.
// 
// Relationships:
// - One-to-Many with Sale: A user (client) can make multiple purchases
// - One-to-Many with Refund: A user can request multiple refunds
model User {
  id       Int     @id @default(autoincrement())
  name     String  @unique @map("name")
  role     String  @default("client")
  password String  @default("password") // Simple authentication
  sales    Sale[]
  refunds  Refund[]

  @@map("User")
}

// Sale Model
// 
// Represents a sales transaction made by a user at a specific store.
// Each sale consists of multiple line items and has a total amount.
// 
// Relationships:
// - Many-to-One with Store: Each sale occurs at one store
// - Many-to-One with User: Each sale is made by one user (client)
// - One-to-Many with SaleLine: A sale consists of multiple line items
// - One-to-Many with Refund: A sale can have multiple partial refunds
model Sale {
  id         Int         @id @default(autoincrement())
  date       DateTime    @default(now())
  total      Float
  status     String      @default("active") // active, refunded, partially_refunded
  store      Store       @relation(fields: [storeId], references: [id])
  storeId    Int         @map("storeId")
  user       User        @relation(fields: [userId], references: [id])
  userId     Int
  lines      SaleLine[]
  refunds    Refund[]

  @@map("Sale") 
}

// SaleLine Model
// 
// Represents a single product line in a sales transaction.
// Contains quantity, unit price, and references to the sale and product.
// 
// Relationships:
// - Many-to-One with Sale: Each line item belongs to one sale
// - Many-to-One with Product: Each line item references one product
model SaleLine {
  id          Int     @id @default(autoincrement())
  quantity    Int     @map("quantity")
  unitPrice   Float   @map("unitPrice")
  sale        Sale    @relation(fields: [saleId], references: [id])
  saleId      Int     @map("saleId")
  product     Product @relation("ProductToSaleLine", fields: [productId], references: [id])
  productId   Int

  @@map("SaleLine")
}

// Refund Model
// 
// Represents a refund transaction associated with a sale.
// Each refund consists of multiple line items and has a total amount.
// 
// Relationships:
// - Many-to-One with Sale: Each refund is associated with one sale
// - Many-to-One with Store: Each refund is processed at one store
// - Many-to-One with User: Each refund is requested by one user
// - One-to-Many with RefundLine: A refund consists of multiple line items
model Refund {
  id          Int             @id @default(autoincrement())
  date        DateTime        @default(now())
  total       Float
  reason      String?
  sale        Sale            @relation(fields: [saleId], references: [id])
  saleId      Int             @map("saleId")
  store       Store           @relation(fields: [storeId], references: [id])
  storeId     Int             @map("storeId")
  user        User            @relation(fields: [userId], references: [id])
  userId      Int
  lines       RefundLine[]

  @@map("Refund")
}

// RefundLine Model
// 
// Represents a single product line in a refund transaction.
// Contains quantity, unit price, and references to the refund and product.
// 
// Relationships:
// - Many-to-One with Refund: Each refund line item belongs to one refund
// - Many-to-One with Product: Each refund line item references one product
model RefundLine {
  id          Int      @id @default(autoincrement())
  quantity    Int      @map("quantity")
  unitPrice   Float    @map("unitPrice")
  refund      Refund   @relation(fields: [refundId], references: [id])
  refundId    Int
  product     Product  @relation("ProductToRefundLine", fields: [productId], references: [id])
  productId   Int

  @@map("RefundLine")
}

// Saga Model
// 
// Represents a saga orchestration instance for managing distributed transactions.
// Each saga tracks the state of a complex business workflow across multiple services.
// 
// Relationships:
// - One-to-Many with SagaStepLog: A saga has multiple step execution logs
model Saga {
  id              Int             @id @default(autoincrement())
  correlationId   String          @unique @map("correlationId")
  state           String          @map("state")
  currentStep     String?         @map("currentStep")
  context         Json            @map("context")
  createdAt       DateTime        @default(now()) @map("createdAt")
  updatedAt       DateTime        @updatedAt @map("updatedAt")
  completedAt     DateTime?       @map("completedAt")
  errorMessage    String?         @map("errorMessage")
  compensationData Json?          @map("compensationData")
  stepLogs        SagaStepLog[]

  @@index([correlationId])
  @@index([state])
  @@index([createdAt])
  @@map("Saga")
}

// SagaStepLog Model
// 
// Represents the execution log of a single step within a saga workflow.
// Tracks timing, success/failure, and step-specific data for monitoring and debugging.
// 
// Relationships:
// - Many-to-One with Saga: Each step log belongs to one saga
model SagaStepLog {
  id            Int       @id @default(autoincrement())
  saga          Saga      @relation(fields: [sagaId], references: [id])
  sagaId        Int       @map("sagaId")
  stepName      String    @map("stepName")
  state         String    @map("state")
  startedAt     DateTime  @default(now()) @map("startedAt")
  completedAt   DateTime? @map("completedAt")
  duration      Int?      @map("duration") // in milliseconds
  success       Boolean?  @map("success")
  errorMessage  String?   @map("errorMessage")
  stepData      Json?     @map("stepData")

  @@index([sagaId])
  @@index([stepName])
  @@map("SagaStepLog")
}

// EventStore Model
// 
// Represents stored domain events for event sourcing and replay functionality.
// Each event is immutable and contains the full event data with metadata.
// 
// Relationships:
// - Self-contained model for event storage
model EventStore {
  id            Int       @id @default(autoincrement())
  eventId       String    @unique @map("eventId")
  eventType     String    @map("eventType")
  aggregateId   String    @map("aggregateId")
  aggregateType String    @map("aggregateType")
  eventData     Json      @map("eventData")
  metadata      Json      @map("metadata")
  version       Int       @map("version")
  createdAt     DateTime  @default(now()) @map("createdAt")

  @@index([aggregateId])
  @@index([aggregateType])
  @@index([eventType])
  @@index([createdAt])
  @@index([aggregateId, version])
  @@unique([aggregateId, version])
  @@map("EventStore")
}

// EventSnapshot Model
// 
// Represents snapshots of aggregate state for performance optimization.
// Snapshots allow faster reconstruction of aggregate state without replaying all events.
// 
// Relationships:
// - Self-contained model for snapshot storage
model EventSnapshot {
  id            Int       @id @default(autoincrement())
  aggregateId   String    @map("aggregateId")
  aggregateType String    @map("aggregateType")
  version       Int       @map("version")
  data          Json      @map("data")
  createdAt     DateTime  @default(now()) @map("createdAt")

  @@index([aggregateId])
  @@index([aggregateType])
  @@unique([aggregateId, version])
  @@map("EventSnapshot")
}

// AuditLog Model
// 
// Represents comprehensive audit logs for tracking all system activities.
// Captures events, user actions, system changes, and security events.
// 
// Relationships:
// - Self-contained model for audit logging
model AuditLog {
  id              Int       @id @default(autoincrement())
  auditId         String    @unique @map("auditId")
  eventType       String    @map("eventType")
  entityType      String    @map("entityType")
  entityId        String    @map("entityId")
  action          String    @map("action")
  userId          String?   @map("userId")
  serviceName     String    @map("serviceName")
  correlationId   String    @map("correlationId")
  causationId     String?   @map("causationId")
  metadata        Json      @map("metadata")
  details         Json      @map("details")
  ipAddress       String?   @map("ipAddress")
  userAgent       String?   @map("userAgent")
  timestamp       DateTime  @default(now()) @map("timestamp")

  @@index([eventType])
  @@index([entityType])
  @@index([entityId])
  @@index([userId])
  @@index([serviceName])
  @@index([correlationId])
  @@index([timestamp])
  @@index([action])
  @@map("AuditLog")
}

// AuditTrail Model
// 
// Represents aggregated audit trails for specific entities or processes.
// Provides a high-level view of audit activities over time.
// 
// Relationships:
// - Self-contained model for audit trail aggregation
model AuditTrail {
  id              Int       @id @default(autoincrement())
  trailId         String    @unique @map("trailId")
  entityType      String    @map("entityType")
  entityId        String    @map("entityId")
  processName     String    @map("processName")
  correlationId   String    @map("correlationId")
  startTime       DateTime  @map("startTime")
  endTime         DateTime? @map("endTime")
  status          String    @map("status") // STARTED, IN_PROGRESS, COMPLETED, FAILED
  totalEvents     Int       @default(0) @map("totalEvents")
  metadata        Json      @map("metadata")
  createdAt       DateTime  @default(now()) @map("createdAt")
  updatedAt       DateTime  @updatedAt @map("updatedAt")

  @@index([entityType])
  @@index([entityId])
  @@index([processName])
  @@index([correlationId])
  @@index([status])
  @@index([startTime])
  @@index([endTime])
  @@map("AuditTrail")
}

// ComplaintSagaState Model
// 
// Represents the state of choreographed complaint handling sagas.
// Tracks saga progress through event correlation and provides state persistence.
// 
// Relationships:
// - Self-contained model for complaint saga state tracking
model ComplaintSagaState {
  id                    Int       @id @default(autoincrement())
  sagaId                String    @unique @map("saga_id")
  complaintId           String    @map("complaint_id")
  correlationId         String    @unique @map("correlation_id")
  customerId            String    @map("customer_id")
  orderId               String?   @map("order_id")
  storeId               Int       @default(1) @map("store_id")
  
  // Saga metadata
  initiatedAt           DateTime  @map("initiated_at")
  completedAt           DateTime? @map("completed_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")
  status                String    @default("INITIATED") @map("status")
  currentStep           String    @default("SAGA_INITIATED") @map("current_step")
  version               Int       @default(1) @map("version")
  
  // Business data (stored as JSONB for flexibility)
  complaintData         Json      @map("complaint_data")
  
  // Step results (stored as JSONB for flexibility)
  customerValidation    Json?     @map("customer_validation")
  orderVerification     Json?     @map("order_verification")
  resolutionProcessing  Json?     @map("resolution_processing")
  compensation          Json?     @map("compensation")
  
  // Error and execution tracking
  errors                Json      @default("[]") @map("errors")
  stepHistory           Json      @default("[]") @map("step_history")

  @@index([sagaId])
  @@index([complaintId])
  @@index([correlationId])
  @@index([customerId])
  @@index([status])
  @@index([currentStep])
  @@index([initiatedAt])
  @@map("complaint_saga_states")
}